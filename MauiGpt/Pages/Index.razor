@page "/"
@using Microsoft.JSInterop
@using MauiGpt.Data
@using Markdig
@using Markdown.ColorCode
@inject IJSRuntime JS
@inject OpenAiService OpenAiService

<style>
    .chat-container {
        display: flex;
        flex-direction: column;
        height: 90vh;
    }
    .chat-list {
        flex: 1; /* The top div will take up all remaining space */
        background-color: #f2f2f2;
    }

    .chat-input {
        background-color: #ccc;
        height: 3em;
        padding: 4px;
    }
    .input-question {
        width: 80%;
    }
    p {
        margin-bottom: 0.5em;
    }
    .answer-padding {
        padding: 0.7rem 1rem 0rem 1rem;
    }

/*    pre code {
        background-color: #eee;
        border: 1px solid #999;
        display: block;
        padding: 20px;
    }*/
</style>

<div class="chat-container">
<div class="chat-list" @ref="_scrollList">

    @foreach (var line in _lines)
    {
        @((MarkupString)line)
    }
    @((MarkupString)@_partMessage)
</div>
    <div class="chat-input">
        <input type="text" class="input-question" @bind="_chatQuestion" @onkeyup="QuestionKeyUp">
        <button class="btn btn-primary" @onclick="AddText">Send</button>
        <button class="btn btn-secondary" @onclick="ClearHistory">Clear</button>
    </div>
</div>


@code {
    private string _chatQuestion;

    private readonly IList<string> _lines = new List<string>();
    private ElementReference _scrollList;

    private string _partMessage;

    // private readonly MarkdownPipeline _markdownPipeline = new MarkdownPipelineBuilder().UseAdvancedExtensions().UseColorCode().Build();

    protected override async Task OnInitializedAsync()
    {
       var trans = await ColorCodeblock(@"
for (int i = 0; i < n; i++)
{
    if (i == 0)
    {
        Console.Write(""{ 0}
        "", a);
    }
    else if (i == 1)
    {
        Console.Write(""{0} "", b);
    }
    else
    {
        c = a + b;
        a = b;
        b = c;
        Console.Write(""{0} "", c);
    }
}
");
//        _partMessage = $"<pre><code>{trans}</code></pre>";
    }

    private async Task QuestionKeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await AddText();
        }
    }


    private void CallbackPartMessage(string part)
    {
        _partMessage = FormatAnswer(part);
        StateHasChanged();
    }

    private void ClearHistory()
    {
        OpenAiService.ClearHistory();
        _lines.Add(FormatQuestion("History Cleared!"));
    }

    private async Task AddText()
    {
        string data = string.IsNullOrEmpty(_chatQuestion) ? "Empty input" : _chatQuestion;
        _lines.Add(FormatQuestion(data));

        if (string.IsNullOrEmpty(_chatQuestion) == false)
        {
            var question = _chatQuestion;
            _chatQuestion = "";
            var answer = await OpenAiService.Ask(question, CallbackPartMessage);
            var result = FormatAnswer(answer);
//            var colored = await ColorCodeblock(result);
            _lines.Add(result);
        }

        _chatQuestion = "";
        _partMessage = "";
    }

    private string FormatQuestion(string data)
    {
        var formattedData = $"<div class='card rounded bg-primary m-2'><div class='card-body answer-padding'>{data}</div></div>";
        return formattedData;
    }

    private  string FormatAnswer(string data)
    {
        var formattedData = Markdown.ToHtml(data);
//        var formattedData = Markdown.ToHtml(data, _markdownPipeline);
        return $"<div class='card rounded bg-secondary m-2'><div class='card-body answer-padding'>{formattedData}</div></div>";
    }

    private async Task<string> ColorCodeblock(string uncolored)
    {
        return await JS.InvokeAsync<string>("colorCodeblock", uncolored);

    }

    private async Task ColorAllCode()
    {
        await JS.InvokeVoidAsync("colorAllCode");
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await JS.InvokeVoidAsync("colorAllCode");
        await JS.InvokeVoidAsync("scrollToEnd",_scrollList);
    }
}