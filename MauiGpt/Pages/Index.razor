@page "/"
@using MauiGpt.Data
@using Markdig
@using MauiGpt.Dto
@using System.Text
@using MauiGpt.Svg

@inject IJSRuntime JsRuntime
@inject OpenAiService OpenAiService
@inject MarkdownToHtml MarkdownToHtml


<div class="container">
    <div class="top">
        <div class="scroll-list" @ref="_scrollList">
            @foreach (var line in _lines)
            {
                var messageClass = MessageClasses[line.Type];

                <div class="@messageClass">
                    @foreach (var block in line.HtmlBlocks)
                    {
                        if (block.Type == BlockType.Code)
                        {
                            Guid guid = Guid.NewGuid();
                            <pre>
                                <code class='hljs'>
                                    <div class="chat-code-heading">
                                        <a onclick="copyToClipboard('@guid')" title="Copy code">
                                            <CopyIcon />
                                        </a>
                                    </div>
                                    <span id="@guid">
                                        @((MarkupString)block.Html)
                                    </span>
                                </code>
                            </pre>
                        }
                        else
                        {
                            @((MarkupString)block.Html)
                        }
                    }
                </div>
            }
        </div>
    </div>
    
    <div class="bottom">
        <div class="chat-input-container">
            <input class="chat-input-field" type="text" @bind="_chatQuestion" @onkeyup="QuestionKeyUp">
            <a @onclick="AddText" title="Send" class="chat-input-icon"><SendIcon/></a>
            <a @onclick="ClearHistory" title="Clear history" class="chat-input-icon"><SkipBackIcon/></a>
            <a @onclick="ClearConversation" title="Clear conversation" class="chat-input-icon"><TrashIcon/></a>
        </div>
        @if (_answerInProgress)
        {
            <div class="chat-cancel-container">
                <a @onclick="CancelAnswer" title="Cancel answer" class="chat-cancel">Cancel!</a>
            </div>
        }
    </div>
</div>


@code {
    private string _chatQuestion;
    private bool _answerInProgress = false;
    private CancellationTokenSource _cancellationTokenSource = new CancellationTokenSource();
    private IList<ChatMessageDto> _lines = new List<ChatMessageDto>();

    private ElementReference _scrollList;

    private static readonly Dictionary<ChatMessageType, string> MessageClasses = new()
    {
        { ChatMessageType.Question, "gpt-question" },
        { ChatMessageType.Answer, "gpt-answer" },
        { ChatMessageType.Error, "gpt-error" }
    };

    private async Task QuestionKeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await AddText();
        }
    }


    private async Task CallbackPartMessage(string part)
    {
        IList<HtmlBlock> htmlBlocks = await MarkdownToHtml.Convert(part, ColorCodeblock);
        var temporaryLine = _lines.LastOrDefault();
        if (temporaryLine?.IsTemporary ?? false)
        {
            temporaryLine.HtmlBlocks = htmlBlocks;
        }
        else
        {
            temporaryLine = ChatMessageDto.GetAnswer(htmlBlocks);
            temporaryLine.IsTemporary = true;
            _lines.Add(temporaryLine);
        }

        StateHasChanged();
    }

    private void ClearHistory()
    {
        OpenAiService.ClearHistory();
        AddQuestion("History Cleared!");
    }

    private void ClearConversation()
    {
        OpenAiService.ClearHistory();
        _lines = new List<ChatMessageDto>();
    }

    private void AddQuestion(string question)
    {
        _lines.Add(ChatMessageDto.GetQuestion(question));
    }

    private async Task AddAnswer(string answer)
    {
        _lines = _lines.Where(item => item.IsTemporary == false).ToList();
        IList<HtmlBlock> htmlBlocks = await MarkdownToHtml.Convert(answer, ColorCodeblock);
        _lines.Add(ChatMessageDto.GetAnswer(htmlBlocks));
    }

    private void AddError(string error)
    {
        _lines.Add(ChatMessageDto.GetError(error));
    }

    private void CancelAnswer()
    {
        _cancellationTokenSource.Cancel();
        _answerInProgress = false;
    }

    private async Task AddText()
    {
        _answerInProgress = true;
        try
        {
            if (string.IsNullOrEmpty(_chatQuestion))
            {
                AddQuestion("Empty input");
            }
            else
            {
                var question = CleanQuestion(_chatQuestion);
                AddQuestion(question);
                _chatQuestion = "";
                var (status, answer) = await OpenAiService.Ask(question, CallbackPartMessage, _cancellationTokenSource.Token);
                //var (status, answer) = await OpenAiService.Ask(question, CallbackPartMessage, new CancellationToken());

                if (status == AiAnswerType.Error)
                {
                    AddError(answer);
                }
                else
                {
                    await AddAnswer(answer);
                }
            }
        }
        finally
        {
            _answerInProgress = false;
            _cancellationTokenSource = new CancellationTokenSource();
        }
    }

    private async Task<string> ColorCodeblock(string language, string codeData)
    {
        return await JsRuntime.InvokeAsync<string>("colorCodeblock", codeData);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await JsRuntime.InvokeVoidAsync("scrollListToEnd", _scrollList);
    }

    private string CleanQuestion(string input)
    {
        string result = input
            .Replace("<", "[")
            .Replace(">", "]");

        return result;
    }
}