@page "/"
@using MauiGpt.Data
@using Markdig
@using MauiGpt.Dto
@using System.Text
@inject IJSRuntime JsRuntime
@inject OpenAiService OpenAiService
@inject MarkdownToHtml MD


<div class="container">
    <div class="top">
        <div class="scroll-list" @ref="_scrollList">
            @foreach (var line in _lines)
            {
                switch (line.Type)
                {
                    case ChatMessageType.Answer:
                        <div class="gpt-answer">
                            @((MarkupString)line.Message)
                        </div>
                        break;
                    case ChatMessageType.Question:
                        <div class="gpt-question">
                            @((MarkupString)line.Message)
                        </div>
                        break;
                    case ChatMessageType.Error:
                        <div class="gpt-error">
                            @((MarkupString)line.Message)
                        </div>
                        break;
                }
            }
            @if (string.IsNullOrWhiteSpace(_partMessage) == false)
            {
                <div class="gpt-answer">
                    @((MarkupString)@_partMessage)
                </div>
            }
        </div>
    </div>
    <div class="bottom">
        <div class="chat-input-container">
            <input class="chat-input-field" type="text" @bind="_chatQuestion" @onkeyup="QuestionKeyUp">
            <a class="chat-input-send" @onclick="AddText">Send</a>
            <a class="chat-input-clear" @onclick="ClearHistory">Clear</a>
            <a class="chat-input-clear" @onclick="Lab">Lab</a>
        </div>
    </div>
</div>


@code {
    private string _chatQuestion;

    private readonly IList<ChatMessageDto> _lines = new List<ChatMessageDto>();
    private ElementReference _scrollList;

    private string _partMessage;

    private async Task QuestionKeyUp(KeyboardEventArgs e)
    {
        if (e.Key == "Enter")
        {
            await AddText();
        }
    }


    private async Task CallbackPartMessage(string part)
    {
        _partMessage = await ConvertMarkdownToHtml(part);
        StateHasChanged();
    }

    private async Task<string> ConvertMarkdownToHtml(string markdown)
    {
        var blocks = MD.GetBlocks(markdown);

        StringBuilder builder = new StringBuilder();

        foreach (var block in blocks)
        {
            if (block.type == MarkdownToHtml.MdText)
            {
                var html = Markdown.ToHtml(block.content);
                builder.Append(html);
            }
            else
            {
                string colored = await ColorCodeblock(block.content);
                builder.Append($"<pre><code class='hljs'><div>HelloWorld</div>{colored}</pre></code>");
            }
        }

       return builder.ToString();
    }

    private void ClearHistory()
    {
        OpenAiService.ClearHistory();
        AddQuestion("History Cleared!");
    }

    private void AddQuestion(string question)
    {
        _lines.Add(new ChatMessageDto { Type=ChatMessageType.Question, Message=question});
    }

    private async Task AddAnswer(string answer)
    {
        var formattedAnswer = await ConvertMarkdownToHtml(answer);
        _lines.Add(new ChatMessageDto { Type = ChatMessageType.Answer, Message = formattedAnswer });
    }

    private void AddError(string answer)
    {
        _lines.Add(new ChatMessageDto { Type = ChatMessageType.Error, Message = answer });
    }


    private async Task AddText()
    {
        if (string.IsNullOrEmpty(_chatQuestion))
        {
            AddQuestion("Empty input");
        }
        else
        {
            var question = CleanQuestion(_chatQuestion);
            AddQuestion(question);
            _chatQuestion = "";
            var (status, answer) = await OpenAiService.Ask(question, CallbackPartMessage);

            if (status == OpenAiService.AnswerType.Error)
            {
                AddError(answer);
            }
            else
            {
                await AddAnswer(answer);
            }
        }

        _partMessage = "";
    }

    private async Task<string> ColorCodeblock(string uncolored)
    {
        return await JsRuntime.InvokeAsync<string>("colorCodeblock", uncolored);

    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        await JsRuntime.InvokeVoidAsync("scrollListToEnd", _scrollList);
    }

    private string CleanQuestion(string input)
    {
        string result = input
            .Replace("<", "[")
            .Replace(">", "]");

        return result;
    }

    private async Task Lab()
    {
        var st = await CopySelectedText();
    }

    private async Task<string> CopySelectedText()
    {
        string selectedText = await JsRuntime.InvokeAsync<string>("getSelectionText");
        return selectedText;
    }
}